#lang s-exp rosette
(require "util.rkt")
(require "../tests/hw2-1-t.rkt")

(define-symbolic i0 number?)
(configure [bitwidth 32] [loop-bound 20])

(define-syntax-rule (either a ...)
	(choose (list a ...)))

(define (choose lst)
	(define-symbolic* choice number?)
	(list-ref lst choice))

(define (n?)
	(define-symbolic* n number?)
	(assert (and (< n 10) (>= n -10)))
	n)

(define (n??)
	(define-symbolic* nn number?)
	(assert (and (< nn 10) (>= nn -10)))
	nn)

(define (square x)
	(define (v?)
		(define-symbolic* v number?)
		(cond
			[(= v 0) x]
	))
	(define (v??)
		(define-symbolic* vv number?)
		(cond
			[(= vv 0) x]
	))
	(define (??)
		(define-symbolic* is-var boolean?)
		(if is-var (v??) (n??)))

 ( * x x))

(define (product_s n)
	(define (v?)
		(define-symbolic* v number?)
		(cond
			[(= v 0) k]
			[(= v 1) total]
			[(= v 2) n]
	))
	(define (v??)
		(define-symbolic* vv number?)
		(cond
			[(= vv 0) k]
			[(= vv 1) total]
			[(= vv 2) n]
	))
	(define (??)
		(define-symbolic* is-var boolean?)
		(if is-var (v??) (n??)))

(define k #f)
(define total #f)
(set! total (n?) )
(set! k 1)
(while  ( <= k n)
(set! total ( * ( square k) total))
(set! k ( + (v?)  1))
)
 total)
(define model
(synthesize
	#:forall (list i0 )
	#:assume (assert (and (< i0 10) (> i0 -10)))
	#:guarantee (assert (eq? (product_t i0 ) (product_s i0 )))))

(define solution (solution->list model))
(for-each (lambda (sol)
	(define val (cdr sol))
	(define sym (sym-name (car sol)))
	(define symtype (syntax->datum (car sym)))
	(define symid (cdr sym))
	(printf "~a:~a:~a\n" symtype symid val))
	 solution)
